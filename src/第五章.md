# 构建一个根文件系统
根文件系统是嵌入式Linux的第4个也是最后一个组件。当你读完这一节后，你将能够去构建、启动、以及运行一个简单的嵌入式Linux系统。
这里我将介绍的技术一般被称为**roll your own**或者**RYO**。在嵌入式Linux的早期阶段，这是创建根文件系统的唯一办法。现在RYO仍然在一些场景下有所使用，例如RAM或者存储空间非常受限时，快速的demo，或者你的一些需求不被标准的构建系统包含到的情况。不过，这些场景都是比较少出现的。我要强调一下本章节的目的主要是为了教学，这并不代表它可以用于日常的构建，你应该使用下一章介绍的内容来做这件事。
第一个目标是创建一个最小化根文件系统给我们提供一个命令行提示符。之后基于此，我们将添加脚本来启动其他程序和配置网卡以及用户权限。这里有针对BeagleBone Black和QEMU目标的可用的例子。知道如何从scratch构建根文件系统是一个非常有用的技能，它能帮助你理解当我们在后续章节更复杂的例子做了些什么。
在这一章节，我们将会包含如下的主题：
- 根文件系统里应该有什么？
- 将根文件系统移动到目标
- 创建一个启动initramfs
- init程序
- 配置用户账户
- 一个管理设备节点的更佳办法
- 配置网络
- 使用设备表创建文件系统镜像
- 使用NFS挂载根文件系统
- 使用TFTP加载内核

## 技术要求
为了能够实现例子，请确认你有如下列表：
- 一个基于Linux的主机系统
- 一个microSD卡以及读卡器
- SD卡已经基于第四章“配置与构建内核”为BeagleBone Black做好了准备
- 基于第四章“配置与构建内核”，有适合QEMU的zImage和DTB
- USB转3.3V TTL的转换线
- BeagleBone Black
- 5V1A的直流电源
- 网线与NFS和TFTP的端口

本章所有的代码都可以在本书GitHub仓库的*Chapter05*文件夹中找到：https://github.com/PacktPublishing/Mastering-Embedded-Linux-Programming-Third-Edition

## 根文件系统里应该有什么？
内核将会通过bootloader或者内核命令行中的root=parameter参数设定的挂载块设备，得到一个指向根文件系统或者initramfs的指针。一旦内核拥有了根文件系统，内核就会启动第一个程序，默认的第一个程序名是init，正如第四章中*早期用户空间*中介绍的一样。之后，只考虑内核，它的任务就以及完成了。接下来就轮到了init程序来开始启动其他的程序然后唤醒整个系统。
为了制作一个最小化根文件系统，你需要如下组件：
- init：它将通过运行一系列的脚本来启动所有的程序。我将会在第13章“启动 - init程序”中介绍init工作的细节
- Shell：你需要一个shell来给你命令行提示符以及更重要的运行被init或者其他程序调用的shell脚本
- 守护进程：守护进程是一个提供服务给其他进程的后台运行程序。比较好的例子是系统日志的守护进程（syslogd）和ssh的守护进程（sshd）。init程序必须开启许多流行的守护进程来为主要的系统应用提供支持。事实上，init本身自己就是一个守护进程，它会给其他守护进程提供服务
- 动态库：大部分程序都将链接到动态库，所以这些动态库都需要在根文件系统有存储
- 配置文件：对init和其它守护进程的配置将会以一系列文本存储起来，一般放在/etc目录下
- 设备节点：这是一些特殊文件来允许访问各种设备驱动程序
- proc和sys：这是两个伪文件系统能将内核数据结构展示为文件和目录的层次结构。很多程序和库函数都依赖于/proc和/sys
- 内核模块：如果你配置了你的内核的一些部分为模块，那它们也需要被安装到根文件系统中，通常的位置在/lib/modules/[kernerl version]

此外，还有一些为完成预期工作特定于设备的应用程序，以及它们生成的运行时数据文件。
|重要提示：在一些情况下，你可以将上面的大多数程序压缩为一个静态链接的程序，并且直接直接启动这个程序而不是init。例如，如果你的程序名为/myproj，你可以将一下命令添加到内核命令行init=/myproj。我只遇到过一次这样的配置，在一个安全系统中fork系统调用被禁止了，因此无法启动任何其他程序。这样方法的缺点是你无法使用通常在嵌入式设备中使用的许多工具，必须自己做每件事。|
|-----|

### 目录布局
有趣的是，除了init=或者rdinit=指定的程序名之外，Linux内核并不关心文件和目录的布局，所以你可以随意的把东西放在你喜欢的任何地方。例如，将运行Android的设备的文件布局与桌面Linux发行版的文件布局进行比较，你会发现它们完全不同。
然而，许多程序都希望某些文件位于某些特定位置，如果设备都使用类似的布局，这对开发者有帮助，安卓例外。大多数Linux系统的基本布局在文件层次结构标准（Filesystem Hierarchy Standard ，FHS）中定义，该标准在https://refspecs.linuxfoundation.org/fhs.shtml 。FHS涵盖了大大小小所有Linux操作系统的实现。嵌入式设备倾向于根据其需求使用子集，但通常都包含如下内容：
- /bin：对所有用户都至关重要的程序
- /dev：设备节点以及一些特殊的文件
- /etc：系统配置文件
- /lib：重要的动态库，例如组成C库的那些
- /proc：关于进程信息显示为虚拟文件
- /sbin：对系统管理员重要的程序
- /tmp：放置临时或者易失文件的地方
- /usr：其他额外的程序、库、以及系统管理员实用程序，分别放在/usr/bin，/usr/lib，和/usr/sbin目录
- /var：可以在运行时修改的文件和目录的层次结构，例如日志消息，其中的一些会在启动之后保留

这里有一些微妙的区别。/bin和/sbin之间的区别只是后者不需要包含在非root用户的搜索路径中。对于Red Hat衍生发行版的用户对此将非常熟悉。/usr的意义在于，它可能和根文件系统位于一个不同的分区中，因此它不能包含启动系统所需的任何内容。

### 临时目录
你应该首先在主机上创建一个临时目录，在这里你就可以组装最终传输到目标的文件。在以下示例中，我使用了~/rootfs。你需要在其中创建目录的主体结构，例如这样：
```shell
$ mkdir ~/rootfs
$ cd ~/rootfs
$ mkdir bin dev etc home lib proc sbin sys tmp usr var
$ mkdir usr/bin usr/lib usr/sbin
$ mkdir -p var/log
```

为了看的更清楚，你可以像下面例子一样使用tree命令并且使用-d选项来仅仅显示文件夹：
```shell
$ tree -d
.
├── bin
├── dev
├── etc
├── home
├── lib
├── proc
├── sbin
├── sys
├── tmp
├── usr
│ ├── bin
│ ├── lib
│ └── sbin
└── var
 └── log
```

正如我们所看到的，不是所有的目录都具有相同的文件权限，并且目录中每个文件可能具有比目录更严格的权限。

### POSIX文件访问权限
每个进程，在这里的上下文就代表了一个正在运行的程序，都属于一个用户或者一个或者多个用户组。用户是由一个称为user ID或者UID的32位数字表示的。有关用户的信息，包括从UID到用户名的映射，都保存在/etc/passwd中。同样，组是由group ID或称GID表示的，这里的信息会被保存到/etc/group中。总是有一个UID为0的root用户以及一个GID为0的root组。root用户也被称为超级用户，因此在默认配置中，它绕过了大多数的权限检查，可以访问系统中的所有资源。基于Linux系统的安全性，主要考虑的就是限制对root账户的使用。
每个文件以及每个文件夹也都一个所有者并且只属于一个组。进程对文件或者目录的访问权限由一组访问权限标志（称为文件模式）控制。这里共有3个3-bit长的集合表示，其中第一个集合适用于文件的所有者，第二个适用于与文件相同组的成员，第三个适用于其它的所有人。这些bit位用以表示文件的读取（r）、写入（w）和执行（x）权限。由于3个bit刚好代表一个8进制数，所有通常用8进制表示这些bit，如下图所示：
![Fig 5.1 文件访问权限](../images/ch5/Fig5.1.png)

除此之外，还有可能会在最前面上有第4个二进制数，它代表了特殊的含义：
- SUID（4）: 如果进程是可执行的，则会在程序运行时将进程的有效UID更改为文件所有者的有效UID
- SGID（2）：与SUID类似，这会将进程的有效GID更改为文件组的有效GID
- Sticky（1）：在目录中，它将限制删除，因此一个用户无法删除另一个用户的文件。这通常设置在/tmp和/var/tmp上。

SUID可能是最常被使用的。它可以为非root用户提供一个临时权限提升，以超级用户的身份执行任务。一个很好的例子是ping程序，ping打开了一个底层的套接字，这是一个特权操作。为了让普通用户使用ping，这个程序被root拥有并且设置了SUID位，以便在运行ping的时候，无论你的UID是什么，它都会使用UID 0执行。
要设置此前导八进制数字，请使用chmod命令中的4、2、1值。例如，为了在你的临时根目录中设置/bin/ping的SUID，你需要在755之前添加一个4，类似于：
```shell
$ cd ~/rootfs
$ ls -l bin/ping
-rwxr-xr-x 1 root root 35712 Feb 6 09:15 bin/ping
$ sudo chmod 4755 bin/ping
$ ls -l bin/ping
-rwsr-xr-x 1 root root 35712 Feb 6 09:15 bin/ping
```

请注意，第二个ls命令将模式的前3位显示为rws，而之前他它们是rwx。s表示SUID以及被设置。

### 临时目录中的文件所有权权限
出于安全和稳定的原因，将注意力放到即将放置到目标设备上的文件的所有权和权限至关重要。一般来说，你希望限制敏感资源只能由root用户访问，并尽可能少的使用root用户运行程序。最好使用非root用户运行程序，这样如果它们受到外部攻击，它们会尽可能少的向攻击者提供系统资源。例如：名为/dev/mem的设备节点运行访问系统内存，这在某些程序中是必要的。但是，如果每个人都可以读写，那么就没有安全性，因为每个人都可以访问内存的所有内容。因此，/dev/mem应该由root拥有属于root组，并且具有600的模式，该模式拒绝所有者之外的所有人的读写访问。
不过，临时目录有问题。你在那里创建的文件将归你所有，但当它们安装在设备上时，它们应该属于特定的所有者和组，主要是root用户。一个明显的解决方案是在这个阶段使用以下命令将所有权更改为root：
```shell
$ cd ~/rootfs
$ sudo chown -R root:root *
```

问题是，你需要root权限才能运行chown命令，从那时起，你需要成为root才能修改临时目录的任何文件。在你意识到这点以前，你正在以root身份登录进行你所有的开发，这不是一个好主意。这是一个我们稍后再讨论的问题。

### 根文件系统的程序
现在，是时候开始用基本程序和它们所需的支持库、配置和数据文件填充根文件系统了。我将首先概述你需要的程序类型。
#### init程序
init是第一个运行的程序，因此它是根文件系统的重要组成部分。在本章中，我们将使用BusyBox提供的简单init程序。

#### Shell
我们需要一个shell来运行脚本，并且也给我们一个命令提示符，以便我们可以和系统交互。交互式shell在生产环境上可能不是必须的，但它对开发、调试和维护很有用。嵌入式系统常用的Shell有多种：
- bash：这是在桌面Linux上我们都知道并喜欢的大家伙。它是一个Unix Bourne shell的超集，增加了许多扩展和bashisms
- ash：同样基于Bourne shell，它与BSD系列UNIX有着悠久的历史。BusyBox有一个ash的版本，并且经过扩展，它与bash的兼容性更好。因为它比bash更小，所以在嵌入式系统中非常受欢迎
- hush：这是一个非常小的shell，我们在第三章中简要介绍了它。它在内存很少的设备非常有用。有一个hush版本的BusyBox

|注意：如果你希望在目标板上使用ash或者hush，你需要在目标板上测试你的脚本。非常常见的一个问题是，你有时在主机上编写脚本只用bash做了测试，当你把脚本复制到目标板时它就不工作了。|
|----|

列表中的下一个将是系统工具程序。

#### 系统工具程序
Shell知识启动其他程序的一种方式，而shell脚本需要运行一系列程序别去具有流控制和传递程序间信息的列表。为了使shell发挥作用，你需要一些Unix命令行基于的系统工具程序。即便是一个根文件系统，你也需要大约50个系统工具程序。这样会带来两个问题，首先你需要跟踪他们的源代码并进行交叉编译，这是一个相当艰巨的工作。其次，由此产生的程序将占用几十M字节，这在嵌入式Linux只有几M字节的早期确实是个大问题。为了解决这个问题，BusyBox因此而生。

#### BusyBox救援赶到！
BusyBox的起源与嵌入式Linux无关。该项目是由Bruce Perens在1996年为debian安装程序而发起的，这样他就可以从1.44MB的软盘启动Linux。巧合的是，这大约是当代设备上存储的大小，因此嵌入式Linux社区很快就接受了它。自那以后，BusyBox一直是嵌入式Linux的核心。
BusyBox是从头开始编写的，用于执行那些重要的Linux系统工具程序的基本功能。开发人员利用了80:20法则：程序中最有用的80%是由20%的代码实现的。因此，BusyBox工具实现了桌面等效功能的一个子集，但他们所做的工作足以应付大多数情况。
BusyBox所使用的另一个技巧是将所有工具组合成一个二进制文件，从而可以轻松的在他们之间共享代码。它的工作原理是这样的：BusyBox是一个小程序的合集，每个程序都以[applet]_main导出其main函数。例如，cat命令是在coreutils/cat.c中实现的，并导出cat_main。BusyBox本身的main函数将根据参数将调用分配到正确的小程序。
所以，要读取文件，你可以使用要运行的小程序的名称启动BusyBox，后跟小程序所需的任何参数，如下所示：
```shell
$ busybox cat my_file.txt
```

你还可以在不带参数的情况下运行BusyBox，以获取已编译的所有小程序的列表。
以这种方式使用BusyBox相当笨拙，让BusyBox运行cat小程序的更好办法是创建一个从/bin/cat到/bin/BusyBox的符号链接：
```shell
$ ls -l bin/cat bin/busybox
-rwxr-xr-x 1 root root 892868 Feb 2 11:01 bin/busybox
lrwxrwxrwx 1 root root 7 Feb 2 11:01 bin/cat -> busybox
```

当你在命令行中输入cat时，BusyBox就是实际运行的程序。BusyBox只需要通过argv[0]传入的可执行文件的路径，也就是/bin/cat，就可以提取到应用程序名cat，再进行表查找将cat与cat_main进行匹配。这些都是在libbb/appletlib.c中完成的，本节给了简化的代码。
```shell
applet_name = argv[0];
applet_name = bb_basename(applet_name);
run_applet_and_exit(applet_name, argv);
```

BusyBox有300多个小程序，包括一个init程序，几个不同复杂度的shell，以及用于大多数管理任务的实用程序。甚至还有一个简化版本的vi编辑器，你可以用来更改设备上的文本文件。一个典型的BusyBox二进制程序通常只有启用几十个小程序。
总之，BusyBox的典型安装由的那个程序组成，每个小程序都有一个符号链接，但是它的行为会像是多个独立的程序的合集。

#### 构建BusyBox
BusyBox使用与内核相同的Kconfig和Kbuild系统，因此交叉编译非常简单，你可以通过克隆BusyBox的git仓库并切换到你想要的版本（1_31_1是本文撰写时的最新版本）来获取源代码，如下所示：
```shell
$ git clone git://busybox.net/busybox.git
$ cd busybox
$ git checkout 1_31_1
```

你也可以从https://busybox.net/downloads/ 下载相应的TAR文件。
然后，从默认配置开始配置BusyBox，它几乎启用了BusyBox的所有功能：
```shell
$ make distclean
$ make defconfig
```

在这个时候，你可能想运行make menuconfig来微调配置。例如，你几乎肯希望在BusyBox Settings | Installation Options（CONFIG_PREFIX）中设置安装目录以指向暂存目录。然后，你可以按照通常的方式进行交叉编译。如果你的目标是BeagleBone Black，请使用以下命令：
```shell
$ make ARCH=arm CROSS_COMPILE=arm-cortex_a8-linux-gnueabihf-
```

如果，你的目标是Versatile PB的QEMU模拟器，请使用以下命令：
```shell
$ make ARCH=arm CROSS_COMPILE=arm-unknown-linux-gnueabi-
```

无论是哪种情况，结果都是可执行的BusyBox，对于这样的默认配置构建，大小约为900K。如果这个对你太大了，你可以通过更改配置来去除你不需要的程序。
要将BusyBox安装到临时区域中，请使用以下命令：
```shell
$ make ARCH=arm CROSS_COMPILE=arm-cortex_a8-linux-gnueabihf- install
```

这将把二进制文件复制到CONFIG_PREFIX中配置的目录，并创建到它的所有符号链接。
现在，我们将研究Busybox的替代方案，即ToyBox。

#### ToyBox - BusyBox的替代方案
BusyBox并不是你的唯一选择。此外，还有ToyBox，你可以在http://landley.net/toybox/ 找到。这个项目是由Rob Landley发起的，他之前是BusyBox的维护人员。ToyBox的目标与BusyBox相同，但是更对的强调遵守标准，特别是POSIX-2008与LSB 4.1，而较少的强调与标准GNU扩展的兼容性。ToyBox比BusyBox小，部分原因是因为它实现的小程序更少。它的许可证是BSD而不是GPLv2，这使得它与有BSD许可的操作系统（如Android）更好的兼容性。因此ToyBox提供在所有的新的Android设备的使用。截止到最新的0.8.3版本，ToyBox可以构建出一个完整的Linux系统，你只需要给出Linux和ToyBox的代码就可以引导到命令行提示符。

### 根文件系统中的库
程序通常都会链接到库，你可以静态的链接到库，这样目标设备上就不会存在库。但是如果你有两个或者三个以上的程序，这会占用大量不必要的存储空间。因此，你需要将共享库从工具链中复制到暂存目录。你知道应该有哪些库吗？
一种选择是从工具链中的sysroot目录中复制所有的.so文件。与其试图预测要包含那些库，不如假设你的镜像最终需要所有库。这当然是合乎逻辑的，如果你正在创建一个供其他人用于一系列应用程序的平台，那么这将是正确的方法。不过，请注意，完整的glibc是相当大的。在crosstool-NG构建的的glibc2.22的情况下，库、区域支持与其他支持文件将来到33MiB。当然，你可以使用musl-libc或者uClibc-ng来减小它。
另一种选择是只挑选你需要的库，为此你需要一种能够分辨库依赖关系的方法。使用第2章“学习工具链”中的一些知识，我们可以使用readelf命令执行此任务：
```shell
$ cd ~/rootfs
$ arm-cortex_a8-linux-gnueabihf-readelf -a bin/busybox | grep 
"program interpreter"
[Requesting program interpreter: /lib/ld-linux-armhf.so.3]
$ arm-cortex_a8-linux-gnueabihf-readelf -a bin/busybox | grep 
"Shared library"
0x00000001 (NEEDED) Shared library: [libm.so.6]
0x00000001 (NEEDED) Shared library: [libc.so.6]
```

第一个readelf命令在BusyBox二进制文件中搜索包含程序解释器的行。第二个readelf命令在BusyBox二进制中搜索包含共享库的行，现在，你需要在工具链中的sysroot目录中找到这些文件，并将它复制到暂存目录中。请记住，你可以这样找到sysroot：
```shell
$ arm-cortex_a8-linux-gnueabihf-gcc -print-sysroot
/home/chris/x-tools/arm-cortex_a8-linux-gnueabihf/arm-cortex_a8-linux-gnueabihf/sysroot
```

为了减少键入的数量，我将在shell变量中保留一个副本：
```shell
$ export SYSROOT=$(arm-cortex_a8-linux-gnueabihf-gcc -print-sysroot)
```

如果您查看sysroot中的/lib/ld-linux-armhf.so.3，您会发现它实际上是符号链接：
```shell
$ cd $SYSROOT
$ ls -l lib/ld-linux-armhf.so.3
lrwxrwxrwx 1 chris chris 10 Mar 3 15:22 lib/ld-linux-armhf.so.3 -> ld-2.22.so
```

对libc.so.6和libm.so.6重复此练习，您将得到一个包含三个文件和三个符号链接的列表。现在，您可以使用cp-a复制每一个，这将保留符号链接：
```shell
$ cd ~/rootfs
$ cp -a $SYSROOT/lib/ld-linux-armhf.so.3 lib
$ cp -a $SYSROOT/lib/ld-2.22.so lib
$ cp -a $SYSROOT/lib/libc.so.6 lib
$ cp -a $SYSROOT/lib/libc-2.22.so lib
$ cp -a $SYSROOT/lib/libm.so.6 lib
$ cp -a $SYSROOT/lib/libm-2.22.so lib
```

对每个程序重复此过程。
|提示：这样做只是为了获得尽可能小的嵌入式占用。您可能会错过通过dlopen（3）调用加载的库，这些调用主要是插件。当我们在本章后面配置网络接口时，我们将看到一个带有名称服务交换机（NSS）库的示例。|
|----|

#### 通过strip来缩减大小













