# 构建一个根文件系统
根文件系统是嵌入式Linux的第4个也是最后一个组件。当你读完这一节后，你将能够去构建、启动、以及运行一个简单的嵌入式Linux系统。
这里我将介绍的技术一般被称为**roll your own**或者**RYO**。在嵌入式Linux的早期阶段，这是创建根文件系统的唯一办法。现在RYO仍然在一些场景下有所使用，例如RAM或者存储空间非常受限时，快速的demo，或者你的一些需求不被标准的构建系统包含到的情况。不过，这些场景都是比较少出现的。我要强调一下本章节的目的主要是为了教学，这并不代表它可以用于日常的构建，你应该使用下一章介绍的内容来做这件事。
第一个目标是创建一个最小化根文件系统给我们提供一个命令行提示符。之后基于此，我们将添加脚本来启动其他程序和配置网卡以及用户权限。这里有针对BeagleBone Black和QEMU目标的可用的例子。知道如何从scratch构建根文件系统是一个非常有用的技能，它能帮助你理解当我们在后续章节更复杂的例子做了些什么。
在这一章节，我们将会包含如下的主题：
- 根文件系统里应该有什么？
- 将根文件系统移动到目标
- 创建一个启动initramfs
- init程序
- 配置用户账户
- 一个管理设备节点的更佳办法
- 配置网络
- 使用设备表创建文件系统镜像
- 使用NFS挂载根文件系统
- 使用TFTP加载内核

## 技术要求
为了能够实现例子，请确认你有如下列表：
- 一个基于Linux的主机系统
- 一个microSD卡以及读卡器
- SD卡已经基于第四章“配置与构建内核”为BeagleBone Black做好了准备
- 基于第四章“配置与构建内核”，有适合QEMU的zImage和DTB
- USB转3.3V TTL的转换线
- BeagleBone Black
- 5V1A的直流电源
- 网线与NFS和TFTP的端口

本章所有的代码都可以在本书GitHub仓库的*Chapter05*文件夹中找到：https://github.com/PacktPublishing/Mastering-Embedded-Linux-Programming-Third-Edition

## 根文件系统里应该有什么？
内核将会通过bootloader或者内核命令行中的root=parameter参数设定的挂载块设备，得到一个指向根文件系统或者initramfs的指针。一旦内核拥有了根文件系统，内核就会启动第一个程序，默认的第一个程序名是init，正如第四章中*早期用户空间*中介绍的一样。之后，只考虑内核，它的任务就以及完成了。接下来就轮到了init程序来开始启动其他的程序然后唤醒整个系统。
为了制作一个最小化根文件系统，你需要如下组件：
- init：它将通过运行一系列的脚本来启动所有的程序。我将会在第13章“启动 - init程序”中介绍init工作的细节
- Shell：你需要一个shell来给你命令行提示符以及更重要的运行被init或者其他程序调用的shell脚本
- 守护进程：守护进程是一个提供服务给其他进程的后台运行程序。比较好的例子是系统日志的守护进程（syslogd）和ssh的守护进程（sshd）。init程序必须开启许多流行的守护进程来为主要的系统应用提供支持。事实上，init本身自己就是一个守护进程，它会给其他守护进程提供服务
- 动态库：大部分程序都将链接到动态库，所以这些动态库都需要在根文件系统有存储
- 配置文件：对init和其它守护进程的配置将会以一系列文本存储起来，一般放在/etc目录下
- 设备节点：这是一些特殊文件来允许访问各种设备驱动程序
- proc和sys：这是两个伪文件系统能将内核数据结构展示为文件和目录的层次结构。很多程序和库函数都依赖于/proc和/sys
- 内核模块：如果你配置了你的内核的一些部分为模块，那它们也需要被安装到根文件系统中，通常的位置在/lib/modules/[kernerl version]

此外，还有一些为完成预期工作特定于设备的应用程序，以及它们生成的运行时数据文件。
|重要提示：在一些情况下，你可以将上面的大多数程序压缩为一个静态链接的程序，并且直接直接启动这个程序而不是init。例如，如果你的程序名为/myproj，你可以将一下命令添加到内核命令行init=/myproj。我只遇到过一次这样的配置，在一个安全系统中fork系统调用被禁止了，因此无法启动任何其他程序。这样方法的缺点是你无法使用通常在嵌入式设备中使用的许多工具，必须自己做每件事。|
|-----|

### 目录布局
有趣的是，除了init=或者rdinit=指定的程序名之外，Linux内核并不关心文件和目录的布局，所以你可以随意的把东西放在你喜欢的任何地方。例如，将运行Android的设备的文件布局与桌面Linux发行版的文件布局进行比较，你会发现它们完全不同。
然而，许多程序都希望某些文件位于某些特定位置，如果设备都使用类似的布局，这对开发者有帮助，安卓例外。大多数Linux系统的基本布局在文件层次结构标准（Filesystem Hierarchy Standard ，FHS）中定义，该标准在https://refspecs.linuxfoundation.org/fhs.shtml 。FHS涵盖了大大小小所有Linux操作系统的实现。嵌入式设备倾向于根据其需求使用子集，但通常都包含如下内容：
- /bin：对所有用户都至关重要的程序
- /dev：设备节点以及一些特殊的文件
- /etc：系统配置文件
- /lib：重要的动态库，例如组成C库的那些
- /proc：关于进程信息显示为虚拟文件
- /sbin：对系统管理员重要的程序
- /tmp：放置临时或者易失文件的地方
- /usr：其他额外的程序、库、以及系统管理员实用程序，分别放在/usr/bin，/usr/lib，和/usr/sbin目录
- /var：可以在运行时修改的文件和目录的层次结构，例如日志消息，其中的一些会在启动之后保留

这里有一些微妙的区别。/bin和/sbin之间的区别只是后者不需要包含在非root用户的搜索路径中。对于Red Hat衍生发行版的用户对此将非常熟悉。/usr的意义在于，它可能和根文件系统位于一个不同的分区中，因此它不能包含启动系统所需的任何内容。

### 临时目录
你应该首先在主机上创建一个临时目录，在这里你就可以组装最终传输到目标的文件。在以下示例中，我使用了~/rootfs。你需要在其中创建目录的主体结构，例如这样：
```shell
$ mkdir ~/rootfs
$ cd ~/rootfs
$ mkdir bin dev etc home lib proc sbin sys tmp usr var
$ mkdir usr/bin usr/lib usr/sbin
$ mkdir -p var/log
```

为了看的更清楚，你可以像下面例子一样使用tree命令并且使用-d选项来仅仅显示文件夹：
```shell
$ tree -d
.
├── bin
├── dev
├── etc
├── home
├── lib
├── proc
├── sbin
├── sys
├── tmp
├── usr
│ ├── bin
│ ├── lib
│ └── sbin
└── var
 └── log
```

正如我们所看到的，不是所有的目录都具有相同的文件权限，并且目录中每个文件可能具有比目录更严格的权限。

### POSIX文件访问权限




