# 目录表

## 前言

## 第一部分 嵌入式Linux的组成

### 1 出发
#### 选择Linux
#### 什么时候不选择Linux
#### 与玩家见面
#### 贯穿项目生命周期
##### 嵌入式Linux的四个组成元素
#### 开源导航
##### 证书
#### 为嵌入式Linux选择硬件
#### 获取适合于本书的硬件
##### 树莓派4
##### BeagleBone Black
##### QEMU
#### 配置开发环境
#### 总结

### 2 学习工具链
#### 技术要求
#### 工具链介绍
##### 工具链的种类
##### CPU架构
##### 选择C语言库
#### 寻找一个工具链
#### 通过crosstool-NG编译一套工具链
##### 安装crosstool-NG
##### 为BeagleBone Black编译工具链
##### 为QEMU编译工具链
#### 剖析工具链
##### 了解你的交叉编译器
##### sysroot、库与头文件
##### 工具链中的其他工具
##### 查看C语言库的组件
#### 链接到库-静态链接与动态链接
##### 静态库
##### 共享库
#### 交叉编译的艺术
##### 简单的makefiles
##### Autotools
##### 包配置
##### 关于交叉编译的一些问题
##### CMake
#### 总结
#### 延展阅读

### 3 关于Bootloaders
#### 技术要求
#### 一个bootloader应该做什么
#### 启动顺序
##### 阶段1 - ROM 代码
##### 阶段2 - 二级程序加载器
##### 阶段3 - TPL
#### 从引导加载程序到内核
#### 设备树介绍
##### 设备树基础
##### reg属性
##### 标签与中断
##### 设备树包含文件
##### 编译一个设备树
#### U-Boot
##### 构建U-Boot
##### 安装U-Boot
##### 使用U-Boot
##### 启动Linux
##### 移植U-Boot到一个新板
##### 构建与测试
##### Falcon模式
#### 总结

### 4 配置与构建内核
#### 技术要求
#### 内核应该做什么
#### 选择一个内核
##### 内核开发周期
##### 稳定版与长期支持版
#### 构建内核
##### 获取源代码
##### 理解内核配置 - Kconfig
##### 使用LOCALVERSION识别内核
##### 何时应该使用内核模块
#### 编译 - Kbuild
##### 确定要构建什么内核
##### 构建产物
##### 编译设备树
##### 编译模块
##### 清理内核代码
##### 为树莓派4构建一个64位内核
##### 为BeagleBone Black构建一个内核
##### 为QEMU构建一个内核
#### 启动内核
##### 启动树莓派4
##### 启动BeagleBone Black
##### 启动QEMU
##### 内核错误
##### 早期用户空间
##### 内核消息
##### 内核命令行
#### 移植Linux到一块新板
##### 一个新设备树
##### 设置板的兼容属性
#### 总结
#### 辅助阅读

### 5 构建一个根文件系统
#### 技术要求
#### 根文件系统里应该有什么
##### 文件夹布局
##### 暂存目录
##### POSIX文件访问权限
##### 暂存目录中文件的所有权
##### 根文件系统编程
##### 根文件系统库
##### 设备树节点
##### proc与sysfs文件系统
##### 内核模块
#### 移动根文件系统到目标板
#### 创建启动初始化文件系统
##### 独立初始化文件系统
##### 启动初始化文件系统
##### 启动QEMU
##### 启动BeagleBone Black
##### 构建初始化文件系统到内核镜像
##### 使用设备表构建初始化文件系统
##### 老的初始化文件系统格式
#### 初始化编程
##### 开始一个守护进程
#### 配置用户账户
##### 向根文件系统中添加用户账号
#### 管理设备节点的更佳办法
##### 使用devtmpfs的例子
##### 使用mdev的例子
##### 静态设备节点真的这么糟糕吗？
#### 配置网络
##### glibc的网络组件
#### 基于设备表创建文件系统镜像
##### 启动BeagleBone Black
#### 使用NFS挂载根文件系统
##### 基于QEMU测试
##### 基于BeagleBone Black测试
##### 关于文件权限的一些问题
#### 使用TFTP加载内核
#### 总结
#### 延展阅读

### 6 选择一个构建系统
#### 技术要求
#### 构建系统比较
#### 二进制文件分发
#### Buildroot介绍
##### 背景
##### 稳定版与长期支持版
##### 安装
##### 配置
##### 运行
##### 以真实硬件为目标
##### 创建一个自定义BSP
##### 加入你自己的代码
##### 许可证合规性
#### Yocto项目介绍
##### 背景
##### 稳定版与长期支持版
##### 安装Yocto
##### 配置
##### 构建
##### 运行在QEMU目标板
##### 层模型
##### 通过local.conf定制镜像
##### 写一个镜像配方
##### 创建一个SDK
##### 许可证审核
#### 总结
#### 延展阅读

### 7 基于Yocto开发
#### 技术要求
#### 在现有BSP做构建
##### 构建一个现在的BSP
##### Wi-Fi控制
##### 蓝牙控制
##### 添加一个自定义层
#### 通过devtool捕获变更
##### 开发工作流
##### 创建一个新的配方
##### 修改通过配方生成的源代码
##### 升级配方到更新的版本
#### 创建你自己的发行版
##### 选择合适的时机
##### 创建一个新的发行版层
##### 配置你自己的发行版
##### 向你的发行版里添加更多配方
##### 运行时包管理
#### 配置一个远程包服务器
#### 总结
#### 延展阅读

### 8 Yocto 深入探讨
#### 技术要求
#### 分解Yocto的架构与工作流程
##### 元数据
##### 构建任务
##### 镜像生成
#### 分离元数据到层
#### 构建失败疑难解答
##### 隔离错误
##### 转储环境
##### 阅读任务日志
##### 加入更多日志
##### 通过devshell运行命令
##### 依赖绘制
#### 理解BitBake语法和语义
##### 任务
##### 依赖
##### 变量
##### 函数
##### RDEPENDS重提
#### 总结
#### 延展阅读

## 第二部分：系统架构与设计决策

### 9 创建存储策略
#### 技术要求
#### 存储配置
##### NOR flash
##### NAND flash
#### 通过bootloader访问Flash闪存
##### 存储技术设备
##### MMC块驱动
#### Flash闪存的文件系统
##### Flash翻译层
#### NOR和NAND Flash闪存的文件系统
##### JFFS2
##### YAFFS2
##### UBI和UBIFS
#### Managered Flash的文件系统
##### Flashbench
##### 丢弃与修建
##### Ext4
##### F2FS
##### FAT16/32
#### 只读压缩文件系统
##### SquashFS
#### 临时文件系统
#### 使根文件系统只读
#### 文件系统选择
#### 总结
#### 延展阅读

### 10 现场更新软件
#### 技术要求
#### 更新来自哪里
#### 要更新什么
##### Bootloader
##### 内核
##### 根文件系统
##### 系统应用
##### 设备特定数据
##### 需要更新的组件
#### 软件更新的基础
##### 使更新稳健
##### 使更新故障安全
##### 使更新安全
#### 更新机制的类型
##### 对称镜像更新
##### 非对称镜像更新
##### 原子文件更新
#### OTA更新
#### 使用Mender进行本地更新
##### 构建Mender客户端
#### 安装一个更新
#### 使用Mender进行OTA更新
#### 使用balena进行本地更新
##### 创建账户
##### 创建应用
##### 添加设备
##### 安装CLI
##### 发布工程
#### 总结

### 11 连接设备驱动
#### 技术要求
#### 设备驱动的角色
#### 字符设备
#### 块设备
#### 网络设备
#### 在运行时查找设备驱动
##### 从sysfs中获取信息
#### 找到正确的设备驱动
#### 用户空间的设备驱动
##### GPIO
##### LEDs
##### I2C
##### SPI
#### 写一个内核设备驱动
##### 设计一个字符驱动接口
##### 剖析设备驱动
##### 编译内核模块
##### 加载内核模块
#### 发现硬件配置
##### 设备树
##### 平台数据
##### 通过设备驱动连接硬件
#### 总结
#### 延展阅读

### 12 基于原型板开发
#### 技术要求
#### 从原理图映射到设备树源码
##### 读原理图和数据表
##### 在BeagleBone Black上安装Debian
##### 使能spidev
##### 自定义设备树
#### 基于原型板开发
##### 关闭SPI跳线
##### 安装GNSS天线
##### 安装SPI接头
##### 连接SPI跳帽线
#### 使用逻辑分析仪探测SPI信号
#### 通过SPI收取NEMA消息
#### 总结
#### 延展阅读

### 13 启动 - init程序
#### 技术要求
#### 内核启动之后
#### init程序介绍
#### BusyBox init
##### Buildroot init 脚本
#### System V init
##### inittab
##### init.d脚本
##### 添加一个新的守护进程
##### 开启和结束服务
#### systemd
##### 使用Buildroot或者Yocto构建systemd
##### targets、services、units介绍
##### systemd怎么启动系统
##### 添加你自己的服务
##### 添加watchdog
##### 对嵌入式Linux的影响
#### 总结
#### 延展阅读

### 14 从BusyBox runit开始
#### 技术要求
#### 获取BusyBox runit
#### 创建服务目录与文件
##### 服务目录布局
##### 服务配置
#### 服务监控
##### 服务控制
#### 对其他服务的依赖
##### 起始依赖
##### 自定义起始依赖
##### 合起来
#### 专用服务记录
##### 它是如何运行的
##### 向一个服务添加专属记录
##### 日志轮转
#### 信号通知服务
#### 总结
#### 延展阅读

### 15 电源管理
#### 技术要求
#### 用电量测量
#### 缩放时钟频率
##### CPUFreq 驱动
##### 使用CPUFreq
#### 最佳空闲时间选择
##### CPUIdle驱动
##### Tickless操作
#### 关闭外围设备
#### 让系统休眠
##### 电源状态
##### 唤醒事件
##### 从RTC时钟定时唤醒
#### 总结
#### 延展阅读

## 第三部分 编写嵌入式应用

### 16 打包Python
#### 技术要求
##### 获取Docker
#### 追溯打包Python的起源
##### distutils
##### setuptools
##### setup.py
#### 使用pip安装Python包
##### requirements.txt
#### 使用venv管理Python虚拟环境
#### 使用conda安装预编译二进制文件
##### 环境管理
##### 包管理
#### 通过Docker部署Python应用
##### Dockerfile剖析
##### 构建一个Docker镜像
##### 运行一个Docker镜像
##### 下载一个Docker镜像
##### 发布一个Docker镜像
##### 清理
#### 总结
#### 延展阅读

### 17 进程与线程学习
#### 技术要求
#### 进程或者线程？
#### 进程
##### 创建一个新进程
##### 结束一个进程
##### 运行一个不同的程序
##### 守护进程
##### 进程间通信
#### 线程
##### 创建一个新线程
##### 结束一个线程
##### 编译多线程程序
##### 线程间通信
##### 互斥
##### 条件变化
##### 划分问题
#### ZeroMQ
##### 获取pyzmq
##### 进程间传递消息
##### 进程内传递消息
#### 调度
##### 公平与决定论
##### 分时策略
##### 实时策略
##### 策略选择
##### 选择实时策略
#### 总结
#### 延展阅读

### 18 管理内存
#### 技术要求
#### 虚拟内存基础
#### 内核空间布局
##### 内核使用了多少空间？
#### 用户空间内存布局
#### 进程内存表
#### 交换内存
##### 交换到压缩内存（zram）
#### 使用mmap映射内存
##### 使用mmap分配私有内存
##### 使用mmap共享内存
##### 使用mmap访问设备内存
#### 我的应用使用了多少内存
#### 每个进程的内存使用
##### 使用top和ps
##### 使用smem
##### 可以采用的其他工具
#### 识别内存泄漏
##### mtrace
##### Valgrind
#### 内存越界
#### 总结
#### 延展阅读

## 第四部分 调试与性能优化

### 19 使用GDB调试
#### 技术要求
#### GNU调试器
#### 准备调试
#### 调试应用
##### 使用gdbserver远程调试
##### 设置Yocto以远程调试
##### 设置Buildroot以远程调试
##### 开始调试
##### 简单的调试
#### 现场调试
#### 调试fork和线程
#### Core文件
##### 使用GDB查看Core文件
#### GDB用户接口
##### 终端用户接口
##### 数据显示调试器
##### Visual Studio Code
#### 调试内核代码
##### 使用kdbg调试内核代码
##### 一个简单的调试对话
##### 调试早期代码
##### 调试模块
##### 使用kdbg调试内核代码
##### 查看Oops
##### 保存Oops
#### 总结
#### 延展阅读

### 20 分析和追踪
#### 技术要求
#### 观察者效应
##### 符号表与编译标志
#### 开始分析
#### 使用top分析
#### 穷人的分析器
#### perf介绍
##### 使用perf配置内核
##### 使用Yocto构建perf
##### 使用buildroot构建perf
##### 使用perf分析
##### 调用图
##### perf剖析
#### 事件追踪
#### Ftrace介绍
##### Ftrace使用准备
##### Ftrace使用
##### 动态Ftrace与追踪过滤器
##### 事件追踪
#### 使用LTTng
##### LTTng和Yocto
##### LTTng和Buildroot
##### 使用LTTng作内核追踪
#### 使用BPF
##### 使用BRF配置内核
##### 使用Buildroot构建一个BCC工具链
##### 使用BPF追踪工具
#### 使用Valgrind
##### Callgrind
##### Helgrind
#### 使用strace
#### 总结
#### 延展阅读

### 21 实时编程
#### 技术要求
#### 实时是什么
#### 明确不确定性的来源
#### 了解调度延迟
#### 内核抢占
##### 实时Linux内核(PREEMPT_RT)
##### 线程中断处理函数
#### 抢占式内核锁
##### 获取PREEMPT_RT补丁
##### Yocto与PREEMPT_RT
#### 高精度时钟
#### 避免页错误
#### 中断屏蔽
#### 调度延迟测量
##### cyclictest
##### 使用Ftrace
##### 结合cyclictest与Ftrace
#### 总结
#### 延展阅读

### 为什么订阅

### 猜你喜欢

### 索引