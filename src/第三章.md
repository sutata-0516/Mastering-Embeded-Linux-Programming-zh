# 关于Bootloaders

Bootloader（引导加载程序）是嵌入式Linux的第二个元素。它负责启动系统并加载操作系统内核。在本章中，我们将研究Bootloader的角色，特别是它如何使用所谓设备树（也称为扁平化设备树或者FDT）的数据结构将控制权从自身传递给内核。我将介绍设备树的基础知识，因为这将帮助你遵循设备树中描述的连接将其与实际的硬件关联起来。
我将介绍流行的开源Bootloader U-Boot，并向您展示如何使用它来启动目标设备，以及如何自定义它，以便它可以在新设备上运行，以使用BeagleBone Black为例。
在本章中，我们将介绍以下主题：
- Bootloader有什么作用
- 启动顺序
- 从Bootloader转移到内核
- 设备树简介
- U-Boot

让我们开始吧！

## 技术要求
为完成本章节的示例程序，确保你满足如下要求：
- 一个基于Linux的主机系统，安装了设备树编译器、git、make、patch和u-boot-tools或等效工具
- 来自第二章“工具链学习”的适用于BeagleBone Black的Crosstool-NG工具链
- microSD 卡和读卡器
- USB转TTL 3.3V转接头
- BeagleBone Black
- 5V1A的直流电源

本章的所有代码都可以在本书的GitHub存储库的Chapter03文件夹中找到：https://github.com/PacktPublishing/MasteringEmbedded-Linux-Programming-Third-Edition。

## Bootloader是干啥的？
在嵌入式Linux系统中，bootloader主要做两件事：将系统初始化到基础状态和加载内核。事实上，第一个任务在某种程度是第二个任务的附属，因为它只需要让加载内核所需的系统工作。
当执行bootloader的第一行时，在通电或者重启之后，系统通常处于非常小的状态。DRAM控制器未设置，因此无法访问主存储器。同样，其他接口也不可用，因此不可以通过NAND闪存控制器、MMC控制器等访问的存储也不可用。通常情况下，开始阶段位唯一可用的资源是单个CPU，一些片上的静态资源和boot ROM。
系统引导程序由几个阶段的代码组成，每个阶段都会使更多的系统进行下一步运行。引导加载程序的最后一步是将内核加载到RAM中，并为其创建一个运行环境。引导加载程序和内核之间的接口细节是特定于架构的，但是不论是哪种，它都必须做两件事。首先，引导加载程序必须传递包含有关硬件配置信息的结构指针。其次，它必须将一个指针传递到内核命令行。